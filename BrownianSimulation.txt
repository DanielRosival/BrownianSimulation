// BrownianSimulation.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "pch.h"
#include <iostream>
#include <vector>
#include <fstream>
#include <string>
#include "time.h"

#define maxT 10
#define startT 0
#define timeDivistions 50

struct TrajectoryPoint
{
	double t;
	double B;
};

struct Trajectory {
	std::vector<TrajectoryPoint> trajectoryPoints;
};

double rndNormalDistribution(double m, double s)
{
	double pi2 = 2.0*3.14159265358979323846;
	double epsilon = std::numeric_limits<double>::min();	
	double u1, u2;
	do
	{
		u1 = rand() * (1.0 / RAND_MAX);
		u2 = rand() * (1.0 / RAND_MAX);
	} while (u1 <= epsilon);
	double z1;
	double z0;
	z0 = sqrt(-2.0*log(u1))*cos(pi2*u2);
	z1 = sqrt(-2.0*log(u1))*sin(pi2*u2);
	return z0*s+m;
}

void createBrownianTrajectory(std::vector<double> timeDiscretization, Trajectory* input)
{
	double aux = 0.0;
	input->trajectoryPoints.clear();
	TrajectoryPoint trajectoryPoint;
	trajectoryPoint.t = timeDiscretization[0];
	trajectoryPoint.B = 0;
	input->trajectoryPoints.push_back(trajectoryPoint);
	for (int i = 1; i < timeDiscretization.size(); i++)
	{
		trajectoryPoint.t = timeDiscretization[i];
		aux += rndNormalDistribution(0, timeDiscretization[i] - timeDiscretization[i - 1]);
		trajectoryPoint.B = aux;
		input->trajectoryPoints.push_back(trajectoryPoint);
	}
}

std::vector<double> createTimeDiscretization()
{
	std::vector<double> time;
	time.push_back(startT);
	double step = (maxT - startT) / (double)timeDivistions;
	for (int i = 1; i <= timeDivistions; i++)
	{
		time.push_back(time[i - 1] + step);
	}
	return time;
}

bool condition(Trajectory input)
{
	return ((3 * input.trajectoryPoints[1].B < input.trajectoryPoints[2].B) && (input.trajectoryPoints[1].B < 0));
}

void generateFileFromTrajectories(std::vector<Trajectory> trajectories, std::string name)
{
	std::ofstream outfile;
	std::ofstream outfile2;
	int numberOfGoodTrajectories = 0;
	outfile.open(name);
	outfile2.open("vectors_" + name);

	outfile << "<svg version = \"1.1\"" << std::endl
		<< "width = \"1920\" height = \"1080\"" << std::endl
		<< "xmlns = \"http://www.w3.org/2000/svg\">" << std::endl;
	for (int i = 0; i < trajectories.size(); i++)
	{
		outfile << "<polyline points=\"";
		for (int j = 0; j < trajectories[i].trajectoryPoints.size(); j++)
		{
			int t = trajectories[i].trajectoryPoints[j].t * 192;
			int b = 540 - trajectories[i].trajectoryPoints[j].B * 108;
			outfile << t << "," << b << " ";
		}
		if (condition(trajectories[i]))
		{
			outfile << "\" style=\"stroke:green;fill:none\" />" << std::endl;
			numberOfGoodTrajectories += 1;
		}
		else
		{
			outfile << "\" style=\"stroke:black;fill:none\" />" << std::endl;		
		}
	}
	outfile << "<line x1 = \"0\" y1 = \"0\" x2 = \"0\" y2 = \"1080\" style = \"stroke:rgb(0,0,0);stroke-width:2\" />" << std::endl;
	outfile << "<line x1 = \"0\" y1 = \"540\" x2 = \"1920\" y2 = \"540\" style = \"stroke:rgb(0,0,0);stroke-width:2\" />" << std::endl;
	outfile << "<text x=\"25\" y=\"25\" font-size=\"25\"> Probability - "  << ((double)numberOfGoodTrajectories / trajectories.size()) << "</text>" << std::endl;
	outfile << "</svg>";	
	outfile.close();

	outfile2 << "<svg version = \"1.1\"" << std::endl
		<< "width = \"1920\" height = \"1080\"" << std::endl
		<< "xmlns = \"http://www.w3.org/2000/svg\">" << std::endl;
	for (int i = 0; i < trajectories.size(); i++)
	{
		if (condition(trajectories[i]))
		{
			outfile2 << "<circle cx=\"" << (960 + 192 * trajectories[i].trajectoryPoints[1].B) << "\" cy=\"" << (540 - 108 * trajectories[i].trajectoryPoints[2].B) << "\" r=\"4\" fill=\"green\"/>" << std::endl;
		}
		else 
		{
			outfile2 << "<circle cx=\"" << (960 + 192 * trajectories[i].trajectoryPoints[1].B) << "\" cy=\"" << (540 - 108 * trajectories[i].trajectoryPoints[2].B) << "\" r=\"5\" fill=\"black\"/>" << std::endl;
		}
	}
	outfile2 << "</svg>";
	outfile2.close();
}

int main()
{
	Trajectory *trajectory = new Trajectory();
	std::vector<double> timeDisc;
	std::vector<Trajectory> trajectories;

	srand((unsigned int)time(NULL));

	timeDisc = createTimeDiscretization();
	for (int i = 0; i < 100; i++)
	{
		createBrownianTrajectory(timeDisc, trajectory);
		trajectories.push_back(*trajectory);
	}
	generateFileFromTrajectories(trajectories, "trajectories1.svg");
	for (int i = 0; i < 1000; i++)
	{
		createBrownianTrajectory(timeDisc, trajectory);
		trajectories.push_back(*trajectory);
	}
	generateFileFromTrajectories(trajectories, "trajectories2.svg");
	for (int i = 0; i < 10000; i++)
	{
		createBrownianTrajectory(timeDisc, trajectory);
		trajectories.push_back(*trajectory);
	}
	generateFileFromTrajectories(trajectories, "trajectories3.svg");

	delete trajectory;
	return 0;
}
